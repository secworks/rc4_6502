//======================================================================
// rc4.a65
// -------
// An implementation of the RC4 stream cipher.
// The code provides a function for initializing the cipher given
// a 128 bit key. There also also a function for encrypting and
// decrypting a given area.
//
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Labels
//------------------------------------------------------------------
// keylen in bytes. Must be 16, 32.
.label keylen = 16


//------------------------------------------------------------------
// Macros.
//------------------------------------------------------------------
.macro save_regs()
{
                pha
                txa
                pha
                tay
                pha
}

.macro restore_regs()
{
                pla
                tay
                pla
                tax
                pla
}


//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	        :BasicUpstart(start)


//------------------------------------------------------------------
// start
// Simmple program that shows how the rc4 cipher init and update
// routines can be used to enchipher or decipher an area based
// on a given key.
//------------------------------------------------------------------
.pc = $1000     "RC4 example program"
start:
                jsr rc4_init
                jsr rc4_dump_state

key_scan:
                jsr $ffe4
                beq key_scan
                cmp #$0d
                beq done
                jsr rc4_update
                jsr rc4_dump_state
                dec $d020
                jmp key_scan
done: 

                rts


//------------------------------------------------------------------
// rc4_init
// Initialize the rc4 state based on the given key.
//------------------------------------------------------------------
rc4_init:
                :save_regs()
                // Set initial state.
                ldx #$00
init1:          txa
                sta state, x
                inx
                bne init1

                lda #$00
                sta i_ptr
                sta j_ptr

                // Update j pointer using key material and state.
init2:          lda i_ptr
                and #(keylen - 1)
                tay
                lda key, y
                clc
                adc j_ptr
                sta j_ptr
                ldx i_ptr
                lda state, x
                clc
                adc j_ptr
                sta j_ptr

                // Swap state bytes.
                ldx i_ptr
                lda state, x
                sta i_tmp
                ldy j_ptr
                lda state, y
                sta state, x
                lda i_tmp
                sta state, y

                inc i_ptr
                bne init2

                lda #$00
                sta i_ptr
                sta j_ptr

                :restore_regs()
                rts


//------------------------------------------------------------------
// rc4_update
// Update the rc4 state and generate the next keystream byte.
//------------------------------------------------------------------
rc4_update:
                :save_regs()

                // Update pointers.
                inc i_ptr
                ldx i_ptr
                lda state, x
                clc
                adc j_ptr
                sta j_ptr

                // Swap elements.
                ldx i_ptr
                lda state, x
                sta i_tmp
                ldx j_ptr
                lda state, x
                sta j_tmp
                ldx j_ptr
                lda i_tmp
                sta state, x
                ldx i_ptr
                lda i_tmp
                sta state, x

                // Calc k pointer from state and extract keystream byte.
                lda i_tmp
                clc
                adc j_tmp
                txa
                lda state, x
                sta keystream_byte

                :restore_regs()
                rts


//------------------------------------------------------------------
// Support routines for debug and test.
//------------------------------------------------------------------
rc4_dump_state:
                ldx #$00
ds1:            lda state,x
                sta $0400,x
                dex
                bne ds1
                rts

//------------------------------------------------------------------
// State table and variables.
//------------------------------------------------------------------
.pc = $4000     "Tables"

state:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

key:
.byte $01, $02, $03, $04, $05, $06, $07, $08, $ff, $fe, $fd, $fc, $fb, $fa, $f9, $f8

i_ptr:
.byte $00

i_tmp:
.byte $00

j_ptr:
.byte $00

j_tmp:
.byte $00

keystream_byte:
.byte $00


//======================================================================
// rc4.a65
//======================================================================
