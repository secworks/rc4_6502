//======================================================================
// rc4.a65
// -------
// An implementation of the RC4 stream cipher.
// The code provides a function for initializing the cipher given
// a 128 bit key. There also also a function for encrypting and
// decrypting a given area.
//
//
// (c) 2017 Joachim Str√∂mbergson
//======================================================================

//------------------------------------------------------------------
// Basic start code.
//------------------------------------------------------------------
.pc = $0801     "Basic uppstart"
	        :BasicUpstart(start)


//------------------------------------------------------------------
//------------------------------------------------------------------
// Main program implements a few tests by calling the AES code
.pc = $1000     "Main code"
start:
                jsr rc4_init
                jsr rc4_dump_state
                inc $d020

key_scan:
                jsr $ffe4
                beq key_scan
                cmp #$0d
                beq done
                jsr rc4_update
                jsr rc4_dump_state
                dec $d020
                jmp key_scan
done: 

                rts


//------------------------------------------------------------------
// rc4_init
// Initialize the rc4 state based on the given key.
//------------------------------------------------------------------
rc4_init:
                // Set initial state.
                ldx #$00
init1:          txa
                sta state, x
                inx
                bne init1

                lda #$00
                sta i_ptr
                sta j_ptr

                // Update j pointer using key material and state.
init2:          lda i_ptr
                and #$0f
                tay
                lda key, y
                clc
                adc j_ptr
                sta j_ptr
                ldx i_ptr
                lda state, x
                clc
                adc j_ptr
                sta j_ptr

                // Swap state bytes.
                ldx i_ptr
                lda state, x
                sta i_tmp
                ldy j_ptr
                lda state, y
                sta state, x
                lda i_tmp
                sta state, y

                inc i_ptr
                bne init2

                lda #$00
                sta i_ptr
                sta j_ptr

                rts


//------------------------------------------------------------------
// rc4_update
// Update the rc4 state one step.
//------------------------------------------------------------------
rc4_update:

                // Update pointers.
                inc i_ptr
                ldx i_ptr
                lda state, x
                clc
                adc j_ptr
                sta j_ptr

                // Swap elements.
                ldx i_ptr
                lda state, x
                sta i_tmp
                ldx j_ptr
                lda state, x
                sta j_tmp
                ldx j_ptr
                lda i_tmp
                sta state, x
                ldx i_ptr
                lda i_tmp
                sta state, x

                // Get k pointer from state and extract keystream byte.
                lda i_tmp
                clc
                adc j_tmp
                txa
                lda state, x
                sta keystream_byte

                rts


//------------------------------------------------------------------
//------------------------------------------------------------------
rc4_dump_state:
                ldx #$00
ds1:            lda state,x
                sta $0400,x
                dex
                bne ds1
                rts

//------------------------------------------------------------------
// AES S-Box.
//------------------------------------------------------------------
.pc = $4000     "Tables"

state:
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
.byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

key:
.byte $01, $02, $03, $04, $05, $06, $07, $08, $ff, $fe, $fd, $fc, $fb, $fa, $f9, $f8

i_ptr:
.byte $00

i_tmp:
.byte $00

j_ptr:
.byte $00

j_tmp:
.byte $00

keystream_byte:
.byte $00


//======================================================================
// rc4.a65
//======================================================================
